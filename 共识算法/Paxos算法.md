# Paxos 算法

摘自[wikipedia - Paxos 算法](https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95)

## 介绍

Paxos 算法是莱斯利·兰伯特于 1990 年提出的一种**基于消息传递且具有高度容错特性的共识（consensus）算法**。

分布式系统中的节点通信存在两种模型：**共享内存**（Shared memory）和**消息传递**（Messages passing）。基于消息传递通信模型的分布式系统，不可避免的会发生以下错误：**进程可能会慢、被杀死或者重启，消息可能会延迟、丢失、重复**，在基础 Paxos 场景中，先不考虑可能出现消息篡改即拜占庭错误(即虽然有可能一个消息被传递了两次，但是绝对不会出现错误的消息)的情况。**Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的共识**。

## 算法的提出与证明

为描述 Paxos 算法，作者虚拟了一个叫做 Paxos 的希腊城邦，这个岛按照议会民主制的政治模式制订法律。

角色分为**proposers，acceptors 和 learners（允许身兼数职）**。

- proposers 提出提案，提案信息包括提案编号和提议的 value
- acceptor 收到提案后可以接受(accept)提案，若提案获得多数派(majority)的 acceptors 的接受，则该提案被批准(chosen).
- learners 只能“学习”被批准的提案。

划分角色后，就可以更精确的定义问题：

1. 提议的 value 只有在被 proposers 提出后才能被批准（未经批准的决议称为“提案（proposal）”）
2. **在一次 Paxos 算法的执行实例中，只批准(chosen)一个 value**
3. learners 只能获得被批准（chosen）的 value

作者通过不断加强上述 3 个约束(主要是第二个)获得了 Paxos 算法。

批准 value 的过程中，首先 proposers 将 value 发送给 acceptors，之后 acceptors 对 value 进行接受（accept）。**为了满足只批准一个 value 的约束，要求经“多数派(majority)”接受的 value 成为正式的决议（称为”批准“决议）**。这是因为无论是按照人数还是按照权重划分，两组“多数派”至少有一个公共的 acceptor，如果每个 acceptor 只能接受一个 value，约束 2 就能保证。

于是产生一个新的约束：

`P1：一个acceptor必须接受（accept）第一次收到的提案。`

注意 P1 是不完备的，如果一半 acceptors 接受的提案具有 value A，另一半接受的提案具有 value B，那么无法形成多数派，无法批准任何一个 value。

约束 2 并不要求只批准一个提案，暗示可能存在多个提案。只要提案的 value 是一样的，批准多个提案不违背约束 2。于是可以产生约束 P2：

`P2：一旦一个具有value v的提案被批准（chosen），那么之后批准（chosen）的提案必须具有value v。`

注：通过某种方法可以为每个提案分配一个编号，在提案之间建立一个全序关系，所谓“之后”都是指所有编号更大的提案。

如果 P1 和 P2 都能够保证，那么约束 2 就能够保证。

批准一个 value 意味着多个 acceptor 接受（accept）了该 value。因此，可以对 P2 进行加强：

`P2a：一旦一个具有value v的提案被批准（chosen），那么之后任何acceptor再次接受（accept）的提案必须具有value v。`

由于通信是异步的，P2a 和 P1 会发生冲突。**如果一个 value 被批准后，一个 proposer 和一个 acceptor 从休眠中苏醒，前者提出一个具有新的 value 的提案。根据 P1，后者应当接受，根据 P2a，则不应当接受，这种场景下 P2a 和 P1 有矛盾。**于是需要换个思路，转而对 proposer 的行为进行约束：

`P2b：一旦一个具有value v的提案被批准（chosen），那么以后任何proposer提出的提案必须具有value v`

由于 acceptor 能接受的提案都必须由 proposer 提出，所以 P2b 蕴涵了 P2a，是一个更强的约束。

但是根据 P2b 难以提出实现手段。因此需要进一步加强 P2b。

假设一个编号为 m 的 value v 已经获得批准（chosen），来看看在什么情况下对任何编号为 n（n>m）的提案都含有 value v。因为 m 已经获得批准（chosen），显然存在一个 acceptors 的多数派 C，他们都接受（accept）了 v。考虑到任何多数派都和 C 具有至少一个公共成员，可以找到一个蕴涵 P2b 的约束 P2c：

`P2c：如果一个编号为n的提案具有value v，那么存在一个多数派，要么他们中所有人都没有接受（accept）编号小于n的任何提案，要么他们已经接受（accept）的所有编号小于n的提案中编号最大的那个提案具有value v`

可以用数学归纳法证明 P2c 蕴涵 P2b：

假设具有 value v 的提案 m 获得批准，当 n=m+1 时，采用反证法，假如提案 n 不具有 value v，而是具有 value w，根据 P2c，则存在一个多数派 S1，要么他们中没有人接受过编号小于 n 的任何提案，要么他们已经接受的所有编号小于 n 的提案中编号最大的那个提案是 value w。**由于 S1 和通过提案 m 时的多数派 C 之间至少有一个公共的 acceptor**，所以以上两个条件都不成立，导出矛盾从而推翻假设，证明了提案 n 必须具有 value v；

若（m+1）..（N-1）所有提案都具有 value v，采用反证法，假如新提案 N 不具有 value v，而是具有 value w',根据 P2c，则存在一个多数派 S2，要么他们没有接受过 m..（N-1）中的任何提案，要么他们已经接受的所有编号小于 N 的提案中编号最大的那个提案是 value w'。由于 S2 和通过 m 的多数派 C 之间至少有一个公共的 acceptor，所以至少有一个 acceptor 曾经接受了 m，从而也可以推出 S2 中已接受的所有编号小于 n 的提案中编号最大的那个提案的编号范围在 m..（N-1）之间，而根据初始假设，m..（N-1）之间的所有提案都具有 value v，所以 S2 中已接受的所有编号小于 n 的提案中编号最大的那个提案肯定具有 value v，导出矛盾从而推翻新提案 n 不具有 value v 的假设。根据数学归纳法，我们证明了若满足 P2c，则 P2b 一定满足。

P2c 是可以通过消息传递模型实现的。另外，引入了 P2c 后，也解决了前文提到的 P1 不完备的问题。

## 算法内容

要满足 P2c 的约束，proposer 提出一个提案前，首先要和足以形成多数派的 acceptors 进行通信，获取他们进行的最近一次接受(accept)的提案（prepare 过程），之后根据回收的信息决定这次提案的 value，形成提案开始投票。当获得多数 acceptors 接受（accept）后，提案获得批准（chosen），由 acceptor 将这个消息告知 learner。这个简略的过程经过进一步细化后就形成了 Paxos 算法。

在一个 paxos 实例中，每个提案需要有不同的编号，且编号间要存在全序关系。可以用多种方法实现这一点，例如将序数和 proposer 的名字拼接起来。

如果一个没有 chosen 过任何 proposer 提案的 acceptor 在 prepare 过程中回答了一个 proposer 针对提案 n 的问题，但是在开始对 n 进行投票前，又接受（accept）了编号小于 n 的另一个提案（例如 n-1），如果 n-1 和 n 具有不同的 value，这个投票就会违背 P2c。因此**在 prepare 过程中，acceptor 进行的回答同时也应包含承诺：不会再接受（accept）编号小于 n 的提案**。这是对 P1 的加强：

`P1a：当且仅当acceptor没有回应过编号大于n的prepare请求时，acceptor接受（accept）编号为n的提案。`

### 决议的提出和批准

通常一个决议分为两个阶段：

1. prepare 阶段：
   1. proposer 选择一个提案编号 n 并将 prepare 请求发送给 acceptors 中的一个多数派；
   2. acceptor 收到 prepare 消息后，如果提案的编号大于它已经回复的所有 prepare 消息(回复消息表示接受 accept)，则 acceptor 将自己上次接受的提案回复给 proposer，并承诺不再回复小于 n 的提案；
2. 批准阶段：
   1. 当一个 proposer 收到了多数 acceptors 对 prepare 的回复后，就进入批准阶段。它要向回复 prepare 请求的 acceptors 发送 accept 请求，包括编号 n 和根据 P2c 决定的 value（如果根据 P2c 没有已经接受的 value，那么它可以自由决定 value）。
   2. 在不违背自己向其他 proposer 的承诺的前提下，acceptor 收到 accept 请求后即批准这个请求。

这个过程在任何时候中断都可以保证正确性。例如如果一个 proposer 发现已经有其他 proposers 提出了编号更高的提案，则有必要中断这个过程。因此为了优化，在上述 prepare 过程中，如果一个 acceptor 发现存在一个更高编号的提案，则需要通知 proposer，提醒其中断这次提案。

### 实例

有 A1, A2, A3, A4, A5 5 位议员，就税率问题进行决议。议员 A1 决定将税率,因此它向所有人发出一个草案。这个草案的内容是：

`现有的税率是什么?如果没有决定，我来决定一下. 提出时间：本届议会第3年3月15日;提案者：A1`

在最简单的情况下，没有人与其竞争;信息能及时顺利地传达到其它议员处。

于是, A2-A5 回应：`我已收到你的提案，等待最终批准`

而 A1 在收到 2 份回复后就发布最终决议：`税率已定为10%,新的提案不得再讨论本问题。`

这实际上退化为二阶段提交协议。

现在我们假设在 A1 提出提案的同时, A5 决定将税率定为 20%:`现有的税率是什么?如果没有决定，我来决定一下.时间：本届议会第3年3月16日;提案者：A5`

草案要通过侍从送到其它议员的案头。A1 的草案将由 4 位侍从送到 A2-A5 那里。现在，负责 A2 和 A3 的侍从将草案顺利送达，负责 A4 和 A5 的侍从则不上班. A5 的草案则顺利的送至 A4 和 A3 手中。

现在, A1, A2, A3 收到了 A1 的提案; A4, A3, A5 收到了 A5 的提案。按照协议, A1, A2, A4, A5 将接受他们收到的提案，侍从将拿着`我已收到你的提案，等待最终批准`的回复回到提案者那里。而 A3 的行为将决定批准哪一个。

在讨论之前我们要明确一点，提案是全局有序的。在这个示例中，是说每个提案提出的日期都不一样。即第 3 年 3 月 15 日只有 A1 的提案；第 3 年 3 月 16 日只有 A5 的提案。不可能在某一天存在两个提案。

**情况一**

假设 A1 的提案先送到 A3 处，而 A5 的侍从决定放假一段时间。于是 A3 接受并派出了侍从。A1 等到了两位侍从，加上自己已经构成一个多数派，于是税率 10%将成为决议。A1 派出侍从将决议送到所有议员处：`税率已定为10%,新的提案不得再讨论本问题。`

A3 在很久以后收到了来自 A5 的提案。由于税率问题已经讨论完毕，开始讨论某些议员在第 3 年 3 月 17 日提出的议案。因此这个 3 月 16 日提出的议案他不去理会。他自言自语地抱怨一句：`这都是老问题了，没有必要讨论了。`

**情况二**

依然假设 A1 的提案先送到 A3 处，但是这次 A5 的侍从不是放假了，只是中途耽搁了一会。这次, A3 依然会将"接受"回复给 A1.但是在决议成型之前它又收到了 A5 的提案。则：

- 如果 A5 的提出时间比 A1 的提案更晚一些，这里确实满足这种情况，因为 3 月 16 日晚于 3 月 15 日。，则 A3 回复：`我已收到您的提案，等待最终批准，但是您之前有人提出将税率定为10%,请明察。`

于是，A1 和 A5 都收到了足够的回复。这时关于税率问题就有两个提案在同时进行。但是 A5 知道之前有人提出税率为 10%，于是 A1 和 A5 都会想全体议员广播：`税率已定为10%,新的提案不得再讨论本问题。`共识到了保证。

- 如果 A5 提案的提出时间比 A1 的提案更早一些。假设 A5 的提案是 3 月 14 日提出，则 A3 直接不理会。

`A1不久后就会广播税率定为10%.`

### 决议的发布

一个方法是当 acceptors 批准一个 value 时，将这个消息发送给所有 learners。但是这个方法会导致消息量过大。

由于假设没有 Byzantine failures，learners 可以通过别的 learners 获取已经通过的决议。因此 acceptors 只需将批准的消息发送给指定的某一个 learner，其他 learners 向它询问已经通过的决议。这个方法降低了消息量，但是指定 learner 失效将引起系统失效。

因此 acceptors 需要**将 accept 消息发送给 learners 的一个子集**，然后由这些 learners 去通知所有 learners。

但是由于消息传递的不确定性，可能会没有任何 learner 获得了决议批准的消息。当 learners 需要了解决议通过情况时，可以让一个 proposer 重新进行一次提案。注意一个 learner 可能兼任 proposer。

### Progress 的保证

根据上述过程当一个 proposer 发现存在编号更大的提案时将终止提案。这意味着提出一个编号更大的提案会终止之前的提案过程。如果两个 proposer 在这种情况下都转而提出一个编号更大的提案，就可能陷入活锁，违背了 Progress 的要求。一般活锁可以通过 **随机睡眠-重试** 的方法解决。这种情况下的解决方案是选举出一个 leader，仅允许 leader 提出提案。但是由于消息传递的不确定性，可能有多个 proposer 自认为自己已经成为 leader。Lamport 在 [The Part-Time Parliament](http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf) 一文中描述并解决了这个问题。

## Multi-Paxos

## Fast-Paxos
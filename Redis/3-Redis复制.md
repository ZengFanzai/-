# Redis 复制

> 翻译 Redis.io 的 Replication 文档

- [Redis 复制](#redis-%e5%a4%8d%e5%88%b6)
  - [主服务器上的关闭持久化时复制的安全性](#%e4%b8%bb%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%b8%8a%e7%9a%84%e5%85%b3%e9%97%ad%e6%8c%81%e4%b9%85%e5%8c%96%e6%97%b6%e5%a4%8d%e5%88%b6%e7%9a%84%e5%ae%89%e5%85%a8%e6%80%a7)
  - [Redis 复制如何工作](#redis-%e5%a4%8d%e5%88%b6%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c)
  - [复制 ID 说明(Replication ID)](#%e5%a4%8d%e5%88%b6-id-%e8%af%b4%e6%98%8ereplication-id)
  - [无磁盘复制](#%e6%97%a0%e7%a3%81%e7%9b%98%e5%a4%8d%e5%88%b6)
    - [配置](#%e9%85%8d%e7%bd%ae)
  - [只读副本](#%e5%8f%aa%e8%af%bb%e5%89%af%e6%9c%ac)
  - [设置一个向对主服务器进行身份验证的副本](#%e8%ae%be%e7%bd%ae%e4%b8%80%e4%b8%aa%e5%90%91%e5%af%b9%e4%b8%bb%e6%9c%8d%e5%8a%a1%e5%99%a8%e8%bf%9b%e8%a1%8c%e8%ba%ab%e4%bb%bd%e9%aa%8c%e8%af%81%e7%9a%84%e5%89%af%e6%9c%ac)
  - [仅允许写入 N 个附加副本](#%e4%bb%85%e5%85%81%e8%ae%b8%e5%86%99%e5%85%a5-n-%e4%b8%aa%e9%99%84%e5%8a%a0%e5%89%af%e6%9c%ac)
  - [Redis 复制如何处理 keys 失效](#redis-%e5%a4%8d%e5%88%b6%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86-keys-%e5%a4%b1%e6%95%88)
  - [在 Docker 和 NAT 中配置复制](#%e5%9c%a8-docker-%e5%92%8c-nat-%e4%b8%ad%e9%85%8d%e7%bd%ae%e5%a4%8d%e5%88%b6)
  - [INFO 和 ROLE 命令](#info-%e5%92%8c-role-%e5%91%bd%e4%bb%a4)
  - [重新启动和故障转移后的部分重新同步](#%e9%87%8d%e6%96%b0%e5%90%af%e5%8a%a8%e5%92%8c%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb%e5%90%8e%e7%9a%84%e9%83%a8%e5%88%86%e9%87%8d%e6%96%b0%e5%90%8c%e6%ad%a5)

在 Redis 复制的基础上（不包括 Redis Cluster 或 Redis Sentinel 作为附加层提供的高可用性功能），使用和配置`leader follower`主从复制非常简单：运行副本 Redis 实例是主实例的精确副本。每次连接断开时，副本将自动重新连接到主数据库，并且无论该主数据库发生什么情况，都将尝试成为它的精确副本。

系统使用三种主要机制：

1. 当主实例和副本实例连接良好时，主节点通过向副本发送命令流来使副本保持更新，为了复制由于以下原因而对主端发生的数据集产生的影响：客户端写入，keys 过期或删除，更改主数据集的任何操作。
2. 当主服务器和副本服务器之间断开连接时(网络问题或由于在主服务器或副本服务器中检测到超时),副本节点重新连接并尝试进行部分重新同步：这意味着它将尝试获取断开连接过程中丢失的部分命令流。
3. 如果无法进行部分重新同步，则副本将请求完全重新同步。这将涉及一个更复杂的过程，在该过程中，主服务器需要创建其所有数据的快照，将其发送到副本，然后在数据集更改时继续发送命令流。

默认情况下，Redis 使用异步复制(低延迟和高性能)是绝大多数 Redis 用例的自然复制模式。但是，Redis 副本异步地确认它们与主服务器定期接收的数据量。因此，主服务器不会每次都等待副本处理命令，但是，如果需要，它能知道哪个副本已经处理了什么命令。这允许具有可选的同步复制。

客户端可以使用 WAIT 命令请求某些数据的同步复制。但是，WAIT 仅能确保其他 Redis 实例中具有指定数量的已确认副本，它不会将一组 Redis 实例转换为具有高度一致性的 CP 系统：在故障转移期间，仍然可以丢失已确认的写入，具体取决于 Redis 持久性的确切配置。但是，使用 WAIT，在发生故障事件后丢失写操作的可能性会大大降低，从而很难触发某些故障模式。 您可以查看 Sentinel 或 Redis 群集文档，以获取有关高可用性和故障转移的更多信息。本文档的其余部分主要描述 Redis 基本复制的基本特征。

以下是有关 Redis 复制的一些非常重要的事实：

- Redis 使用异步复制，副本使用异步复制确认从主节点获取处理的数据量。
- 一个主节点可以有多个副本。
- 副本服务器能够接受来自其他副本的连接。除了将多个副本连接到同一主节点外，副本还可以以类似级联的结构连接到其他副本。从 Redis 4.0 开始，所有子副本将从主服务器接收完全相同的复制流。
- Redis 复制在主服务器端无阻塞。这意味着当一个或多个副本执行初始同步或部分重新同步时，主服务器将继续处理查询。
- 复制在副本也基本上没有阻塞。副本执行初始同步时，假设您在 redis.conf 中配置了 Redis，则它可以使用旧版本的数据集处理查询。否则，您可以配置 Redis 副本以在复制流关闭时将错误返回给客户端。但是，在初始同步之后，必须删除旧的数据集，并且必须加载新的数据集。副本将在此简短窗口期间阻止传入连接（对于非常大的数据集，该连接可能长达数秒）。从 Redis 4.0 开始，可以对 Redis 进行配置，以使旧数据集的删除发生在其他线程中，但是加载新的初始数据集仍将在主线程中发生，并阻塞副本。
- 复制既可以用于可伸缩性，也可以用于只读查询的多个副本（例如，可以将慢速 O（N）操作卸载到副本中），也可以仅用于提高数据安全性和高可用性。
- 可以使用复制来避免主机将这个数据集写入磁盘的开销：一种典型的技术涉及配置主节点 redis.conf 以避免完全保留到磁盘，然后连接配置为不时保存或启用 AOF 的副本。但是，必须小心处理此设置，因为重新启动的主节点将以空数据集开始：如果副本尝试与其同步，则副本也将被清空。

## 主服务器上的关闭持久化时复制的安全性

在使用 Redis 复制的设置中，强烈建议在主数据库和副本数据库中启用持久化。如果不可能（例如，由于磁盘速度非常慢而导致延迟问题），则应将实例配置为避免系统重启后自动重启(**avoid restarting automatically** after a reboot)。

为了更好地理解为什么将持久化已关闭的主服务器配置为自动重启是危险的，请尝试以下故障模式，在该故障模式下会从主服务器及其所有副本中擦除数据：

1. 我们有一个设置，其中节点 A 充当主节点，而持久化已关闭，并且节点 B 和 C 从节点 A 复制。
2. 节点 A 崩溃，但是它具有一些自动重新启动系统，该系统可以重新启动进程。但是，由于关闭了持久化，因此节点将使用空数据集重新启动。
3. 节点 B 和 C 将从空数据集节点 A 复制，因此它们将销毁其有效数据副本。

当将 Redis Sentinel 用于高可用性时，关闭主服务器上的持久化以及开启进程自动重启也是很危险的。例如，主服务器可以足够快速地重新启动，以使 Sentinel 不会检测到故障，从而发生上述故障模式。

每当数据安全很重要，并且复制与配置关闭持久化的主服务器一起使用时，都应禁用实例的自动重启。

## Redis 复制如何工作

每个 Redis 主服务器都有一个复制 ID：它是一个较大的伪随机字符串，用于标记数据集的给定描述。每个主服务器还 采用一个偏移量，该偏移量会针对复制流中要发送到副本的每个字节而增加，以便使用新修改的数据集来更新副本状态。即使没有实际连接副本，复制偏移也会增加，所以基本上每个给定的对：

    Replication ID, offset

标识主服务器数据集的确切版本。

当副本连接到主节点时，它们使用 PSYNC 命令来发送其旧的主数据库复制 ID 和到目前为止已处理的偏移量。这样主节点可以只发送所需的增量部分。但是，如果主节点缓冲区中的 _**backlog**_ 不足，或者副本引用的历史记录（副本 ID）无效，则会发生完全重新同步：在这种情况下，副本将从头开始获取数据集的完整副本。

**完全同步的详细信息如下**：

主节点开始一个后台子进程来生成 RDB 文件。同时，它开始将从客户端接收到的新命令写入缓冲区。当子进程完成 RDB 文件，主节点将数据库文件传输到副本，副本将其保存到磁盘然后将其加载到内存中。然后，主服务器将所有缓冲区的命令发送到副本。这是作为命令流完成的，并且与 Redis 协议本身的格式相同。

您可以自己通过 telnet 尝试。服务器正在执行某些工作时，请连接到 Redis 端口并发出 SYNC 命令。您将看到批量传输，然后主服务器收到的每个命令都会在 telnet 会话中重新发出。实际上，SYNC 是一个较旧的协议，较新的 Redis 实例不再使用，但仍在向后兼容：它不允许部分重新同步，因此现在改用 PSYNC。

如前所述，当主节点-副本节点连接由于某种原因断开时，副本能够自动重新连接。如果主服务器收到多个并发的副本同步请求，它将执行一次后台保存，以便为所有请求提供服务。

## 复制 ID 说明(Replication ID)

复制 ID 基本上标记了数据集的给定 **_history_**。每次实例作为主服务器重启，或将副本提升为主服务器时，都会为此实例生成一个新的复制 ID。TCP 握手后，连接到主数据库的副本将继承其复制 ID。因此，具有相同 ID 的两个实例事实上：它们拥有相同的数据，但可能在不同的时间(So two instances with the same ID are related by the fact that they hold the same data, but potentially at a different time.)。对于拥有最新数据集的给定历史记录（复制 ID），可作为逻辑时间的偏移量来理解。(It is the offset that works as a logical time to understand, for a given history (replication ID) who holds the most updated data set.)

例如，如果两个实例 A 和 B 具有相同的复制 ID，但一个实例的偏移量为 1000，另一个实例的偏移量为 1023，则意味着第一个实例缺少应用于数据集的某些命令。这也意味着，仅通过应用一些命令，A 即可达到与 B 完全相同的状态。

Redis 实例具有两个复制 ID 的原因是由于将副本提升为主节点。故障转移之后，升级后的副本仍需要记住其过去的复制 ID，因为该复制 ID 是以前的主节点的一个。这样，当其他副本将与新的主副本同步时，它们将尝试使用旧的主副本 ID 执行部分重新同步。这将按预期工作，因为将副本提升为主节点时，它会将其辅助 ID 设置为其主 ID，并记住发生此 ID 切换时的偏移量。稍后它将选择一个新的随机复制 ID，因为新的历史记录开始了。处理新的副本连接时，主服务器将其 ID 和偏移量与当前 ID 和辅助 ID 匹配（为安全起见，直到给定的偏移量）。简而言之，这意味着在故障转移之后，连接到新提升的主服务器的副本不必执行完全同步。

> **提升为主节点的副本在故障转移后需要更改其复制 ID 的原因**：由于某些网络分区，旧的主机可能仍在作为主机工作：保留相同的复制 ID 将违反以下事实：任何两个随机实例的 ID 和偏移相同，意味着它们具有相同的数据集。

## 无磁盘复制

通常，完全重新同步需要在磁盘上创建 RDB 文件，然后从磁盘重新加载相同的 RDB，以便对于慢速磁盘，这对于主服务器而言可能是非常压力的操作。 Redis 2.8.18 版是第一个支持无盘复制的版本。在此设置中，子进程直接通过线路将 RDB 发送到副本，而无需使用磁盘作为中间存储。

### 配置

要配置基本的 Redis 复制很简单：只需将以下行添加到副本配置文件中：

    replicaof host port
    replicaof 192.168.1.1 6379

还有一些参数可用于调整主服务器在内存中执行的复制 backlog，以执行部分 ​​ 重新同步。

可以使用`repl-diskless-sync`配置参数启用无盘复制。为了等待更多副本在第一个副本之后到达而开始传输的延迟由`repl-diskless-sync-delay`参数控制。[官方 2.8 版本 redis.conf 文件参考](https://raw.githubusercontent.com/antirez/redis/2.8/redis.conf)；[Redis configuration](https://redis.io/topics/config)

## 只读副本

从 Redis 2.6 开始，副本支持默认情况下启用的只读模式。此行为由 redis.conf 文件中的**replica-read-only** 选项控制，并且可以在运行时使用 **CONFIG SET** 启用和禁用。

只读副本将拒绝所有写入命令，因此由于错误而无法写入副本。这并不意味着该功能旨在将副本实例公开给 Internet，或更普遍地公开给存在不受信任客户端的网络，因为同时也启用了 DEBUG 或 CONFIG 之类的管理命令。但是，可以通过在 redis.conf 使用 **rename-command** 指令禁用相关命令来提高只读实例的安全性。

```text
rename-command FLUSHALL ""
rename-command FLUSHDB  ""
rename-command CONFIG   ""
rename-command DEBUG    ""
```

您可能想知道为什么可以还原只读设置并具有可被写操作作为目标的副本实例。尽管如果副本和主节点重新同步或副本重新启动，这些写操作将被丢弃，但是有一些合法的用例将临时数据存储在可写副本中。

例如，计算慢速 Set 或 Sorted set 操作并将它们存储到本地密钥中是多次观察到的可写副本的用例。

但是请注意，版本 4.0 之前的可写副本无法通过设置生存时间使 keys 到期(writable replicas before version 4.0 were incapable of expiring keys with a time to live set)。这意味着，如果您使用 EXPIRE 或其他为某个键设置最大 TTL 的命令，则该键将泄漏，并且当您使用读取命令访问它时可能不再看到它时，您将在键的计数中看到它且仍会使用内存。因此，通常将可写副本（4.0 版之前的版本）和 keys 与 TTL 混合会造成问题。

Redis 4.0 RC3 和更高版本完全解决了这个问题，现在可写副本能够像主节点一样使用 TTL 回收 keys，但 DB 编号大于 63 写入的密钥除外（但默认情况下，Redis 实例只有 16 个数据库）。

还需注意，由于 Redis 4.0 副本仅在本地写入，不会传播到连接到该实例的子副本。子副本将始终接收与顶级主服务器发送给中间副本的复制流相同的复制流。因此，例如在以下设置中：

    A--->B--->c

即使 B 是可写的，C 也不会看到 B 写入，而是具有与主实例 A 相同的数据集。

## 设置一个向对主服务器进行身份验证的副本

如果您的主数据库通过**requirepass**设置了密码，将副本配置为在所有同步操作中使用该密码很简单。

要在正在运行的实例上执行此操作，请使用 redis-cli 并键入：

    config set masterauth <password>

要永久设置，请将其添加到您的配置文件中：

    masterauth <password>

## 仅允许写入 N 个附加副本

从 Redis 2.8 开始，可以将 Redis 主服务器配置为仅在当前至少有 N 个副本连接到该主服务器时才接受写查询。

但是，由于 Redis 使用异步复制，因此无法确保副本实际上收到了给定的写操作，因此始终存在数据丢失的可能。

**该功能的工作方式如下**：

- Redis 副本每秒对主节点进行一次 ping 操作，确认已处理的复制流数量。
- Redis 的主节点会记住上一次它收到每个副本的 ping 命令。
- 用户可以配置延迟不大于最大秒数的最小副本数。

如果至少有 N 个副本，并且延迟少于 M 秒，则将接受写入。

您可能将其视为一种尽力而为的数据安全机制，其中不能确保给定写入的一致性，但至少将数据丢失的时间窗口期限制为给定的秒数。通常，绑定数据丢失比未绑定数据丢失更好。

如果不满足条件，则主节点将返回一个错误，并且写入将不被接受。

此功能有两个配置参数：

- min-replicas-to-write <number of replicas>
- min-replicas-max-lag <number of seconds>

## Redis 复制如何处理 keys 失效

Redis expires 允许 keys 有有限的生存时间。这样的功能取决于实例计算时间的能力，但是 Redis 副本正确地复制带有过期时间的 keys，即使使用 Lua 脚本更改了这些键。

要实现这种功能，Redis 不能依赖于主服务器和副本服务器具有同步时钟的能力，因为这是一个无法解决的问题，并且会导致竞争状况和数据集差异，因此 Redis 使用`三种主要技术来使过期密钥的复制能够正常工作`：

1. 副本不会使 keys 失效，而是等待主服务器使 keys 失效。当主服务器一个 key 过期（或由于 LRU 而将其退出）时，它会合成 DEL 命令，该命令将传输到所有副本。
2. 但是，由于主服务器驱动的过期，有时副本的内存中可能仍存在在逻辑上已过期的 keys，因为主服务器无法及时提供 DEL 命令。为了解决这个问题，副本使用它的逻辑时钟来报告仅在不违反数据集一致性的`只读操作`中不存在的 keys（因为将收到来自主服务器的新命令）。这样，副本可以避免报告逻辑上已过期但仍然存在的 keys。实际上，使用副本进行缩放的 HTML 片段缓存将避免返回早于所需生存时间的项。
3. 在 Lua 脚本执行期间，不会执行任何 key 过期。当 Lua 脚本运行时，从概念上讲，主服务器中的时间将被冻结，因此在脚本运行的所有时间内，给定键要么存在，要么不存在。这样可以防止 keys 在脚本运行中过期，并且需要以确保在数据集中具有相同效果的方式将相同脚本发送到副本。

将副本提升为主节点后，它将开始独立地使 keys 过期，并且不需要它的旧主节点的任何帮助。

## 在 Docker 和 NAT 中配置复制

当使用端口转发的 Docker 或其他类型的容器或网络地址转换时，Redis 复制需要格外小心，特别是在使用 Redis Sentinel 或扫描主节点 INFO 或 ROLE 命令输出以发现副本地址的其他系统时

问题在于，当发布到主实例中时，ROLE 命令和 INFO 输出的 replication 部分会将副本显示为具有用于连接到主节点的 IP 地址，而在使用 NAT 的环境中，这些副本可能会与副本实例的逻辑地址有所不同（客户端应用于连接副本的逻辑地址）。

同样，副本在 redis.conf 中配置侦听端口，在重新映射端口的情况下，该端口可能与转发端口不同。

为了解决这两个问题，从 Redis 3.2.2 开始，可以强制副本向主节点声明任意 IP 和端口。使用的两个配置指令是：

    replica-announce-ip 5.5.5.5
    replica-announce-port 1234

并且在最近的 Redis 发行版的示例 redis.conf 中进行了记录。

## INFO 和 ROLE 命令

有两个 Redis 命令可提供有关主实例和副本实例的当前复制参数的大量信息。一种是 INFO。如果使用复制参数作为 INFO 复制调用该命令，则仅显示与复制相关的信息。另一个对计算机更友好的命令是 ROLE，它提供了主节点和副本的复制状态以及它们的复制偏移量，已连接副本的列表等。

## 重新启动和故障转移后的部分重新同步

从 Redis 4.0 开始，在故障转移后将实例提升为主节点时，它仍将能够与旧主节点的副本执行部分重新同步。为此，副本会记住旧的复制 ID 和其前主节点的偏移量，因此即使连接的副本要求使用旧的复制 ID，也可以将部分 backlog 提供给连接的副本。

但是，升级副本的新复制 ID 将有所不同，因为它构成了数据集的不同历史记录。例如，主服务器可以返回可用状态，并且可以继续接受写入一段时间，因此在升级副本中使用相同的复制 ID 将违反复制 ID 和偏移对仅标识单个数据集的规则。

此外，副本（在关闭电源并重新启动后）能够将所需的信息存储在 RDB 文件中，以便与主服务器重新同步。这在升级时很有用。如果需要，最好使用 SHUTDOWN 命令在副本上执行保存并退出操作。

重新启动的副本无法通过 AOF 文件进行部分重新同步。但是，可以在关闭实例之前将实例转换为 RDB 持久化，然后再重新启动，最后可以再次启用 AOF。

# Redis 分布式锁

## 安全与活跃保障

由三个属性来设计建模，这三个属性是有效使用分布式锁所需的最低保证：

1. 安全属性：互斥。在任何时刻，只有一个客户端可以持有锁
2. 活性 A：无死锁。即使一个锁定了资源的客户端崩溃或者分区，依旧可以从它那获取锁
3. 活性 B：容错。只要大多数 Redis 节点都处于运行状态，客户端就能获取和释放锁。

## 为什么基于故障转移的实现还不够

1. 单点故障
2. 即使是使用 slave，但无法保证互斥的安全属性，redis 的复制是异步的

模型竞争问题：

1. Client A 在 master 请求一个锁，此时设置一个 key；
2. 在将 key 写入传输到 slave 之前，主机崩溃；
3. slave 提升为 master；
4. 此时 Client B 也获取对该资源的锁定，而该资源已经有 A 锁定，此时安全属性违规。

## 在单实例的正确实现

通过下列方法获取锁：

```txt
SET resource_name my_random_value NX PX 30000
```

该命令仅在 key 不存在（NX 选项）时设置 key，且到期时间为 30000 毫秒（PX 选项）。key 设置一个 value“ myrandomvalue”。value 在所有客户端和所有锁定请求中必须唯一。

基本上，使用随机值是为了以安全的方式释放锁，并且脚本会告诉 Redis：仅当 key 存在且存储 key 对应的 value 恰好是期望的 value 时，才删除该 key。这可以通过 Lua 脚本完成：

```lua
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

为了避免删除另一个客户端创建的锁，这一点很重要。例如，一个客户端可能获取了该锁，但在某些操作中被阻塞的时间超过了该锁的有效时间(key 的过期时间),之后又删除某个其他客户端获得的锁，使用仅使用 DEL 是不安全的，因为一个客户端可能会删除另一个客户端的锁。`上述脚本使用随机字符串保证该锁仍是当前客户端设置的锁才删除该key`。

## Redlock 算法

假设有 N 个 Redis masters，这些节点完全独立，不使用复制或任何其他隐式协调系统。此处设置 N=5，为了获取锁，客户端需要执行以下操作：

1. 获取当前的毫秒时间。
2. 尝试在所有节点实例中使用相同的 key 和随机 value 来依次获取锁。在第二步中，在每个实例中设置锁时，客户端使用的超时时间小于总锁的自动释放时间，以便能获取锁。例如，如果自动释放时间是 10s，超时时间可以设置为 5-50 毫秒，这样可以防止客户端长时间尝试与处于故障状态的 Redis 节点进行通信，而导致阻塞：如果一个实例不可用，应该尽快与下一个实例进行交互。
3. 客户端通过当前时间减去步骤 1 获取得时间来计算获取锁所需的时间。当且仅当客户端能够在大多数实例(N=5 时，至少三个)中获取锁，并且获取锁所花费的总时间小于锁有效时间时，才视为以获取锁。
4. 如果获取了锁，则其有效时间将变为初始有效时间减去已经经过的时间(步骤 3 中获取锁的花费)
5. 如果客户端由于某种原因(无法锁定 N/2+1 个实例或有效时间为负)而未能获得锁该锁时，则它将尝试解锁所有实例(包含它未能锁定的实例)。

### 算法是异步的吗？

算法基于以下假设：

尽管各进程间没有同步时钟，但每个实例的本地时间仍以大约相同的速率流动，并且与锁的自动释放时间相比，误差很小。

在这一点上，需要更好地指定互斥规则：只有在持有锁的客户端将在锁有效时间内（如步骤 3 中获得的）减去一段时间（仅几毫秒，为了补偿进程之间的时钟漂移）后，才能保证其终止工作。参考[Leases: an efficient fault-tolerant mechanism for distributed file cache consistency.](https://dl.acm.org/doi/10.1145/74851.74870)

### 失败重试

当一个客户端不能获取锁时，在随机时延后应该继续尝试，以便尝试使试图同时获取资源的锁的多个客户端不同步（这可能导致没有获胜方的脑裂状况）。同样，客户端在多数Redis实例中尝试获取锁的速度越快，出现脑裂的情况（以及需要重试的情况）就越小，因此在理想情况下，客户端应尝试使用多路复用将SET命名发送到N个实例。

值得强调的是，对于那些无法获取大多数锁的客户端，尽快释放获取的锁是多么重要，以便无需等待key到期才能重新获取锁（然而，如果发生网络分区，并且客户端不再能够与Redis实例进行通信，则在等待key到期时需要支付可用性损失）

### 释放锁

释放锁很简单，只需在所有实例中释放锁，无论客户端是否认为它能够在给定实例中成功获取锁。

### 安全性讨论

我们将从不同的场景分析RedLock算法是否足够安全。首先我们假设一个client在大多数的Redis实例中取得了锁,那么:

1. 每个实例中的锁的剩余存活时间相等为TTL。
2. 每个锁请求到达各个Redis实例中的时间有差异。
3. 第一个锁成功请求最先在T1后返回，最后返回的请求在T2后返回。(T1,T2都小于最大失败时间)
4. 并且每个实例之间存在时钟漂移CLOCK_DRIFT(Time Drift)。

于是，最先被SET的锁将在TTL-(T2-T1)-CLOCK_DIRFT后自动过期，其他的锁将在之后陆续过期。
所以可以得到结论：**所有的key这段时间内是同时被锁住的**。

在这段时间内，一半以上的Redis实例中这个key都处在被锁定状态，其他的客户端无法获得这个锁。

### 活性讨论(Liveness)

系统活跃性基于三个主要特征：

1. 自动释放锁（当key过期时）：最终锁将被释放并且被再次申请
2. 客户端在未申请到锁以及申请到锁并完成任务后都将进行释放锁的操作，所以大部分情况下都不需要等待到锁的自动释放期限，其他client即可重新申请到锁。
3. 当客户端需要重试锁定时，它等待的时间要比获取大多数锁所需的时间长得多，以便在资源争夺期间不太可能出现脑裂

如果一直持续的发生网络故障，那么没有客户端可以申请到锁。分布式锁系统也将无法提供服务直到网络故障恢复为止。

### 性能,故障恢复和fsync

用户使用redis作为锁服务的主要优势是性能。其性能的指标有两个

1. 加锁和解锁的延迟
2. 每秒可以进行多少加锁和解锁操作

所以，在客户端与N个Redis节点通信时，必须使用多路复用的方式(multiplex)，减少通信延时。

为了实现故障恢复还需要考虑数据持久化的问题。针对如下场景：

1. Redis实例的配置不进行任何持久化,集群中5个实例 M1,M2,M3,M4,M5
2. client A获得了M1,M2,M3实例的锁。
3. 此时M1宕机并重启。
4. 由于没有进行持久化，M1重启后不存在任何KEY
5. client B获得M4,M5和重启后的M1中的锁。
6. 此时client A 和Client B 同时获得锁

如果使用AOF的方式进行持久化，情况会稍好一些。例如我们可以向某个实例发送shutdown和restart命令。即使节点被关闭，EX设置的时间仍在计算，锁的排他性仍能保证。

但当Redis发生断电的情况又会遇到有新的问题出现。如果Redis配置中的进行磁盘持久化的时间是每秒进行，那么会有部分key在重新启动后丢失。
如果为了避免key的丢失，将持久化的设置改为`fsync=always`,那么性能将大幅度下降。

另一种解决方案是在这台实例重新启动后，令其在一定时间内不参与任何加锁。在间隔了一整个锁生命周期后，重新参与到锁服务中。这样可以保证所有在这台实例宕机期间内的key都已经过期或被释放。

延时重启机制能够保证Redis即使不使用任何持久化策略，仍能保证锁的可靠性。但是这种策略可能会牺牲掉一部分可用性。

例如集群中超过半数的实例都宕机了，那么整个分布式锁系统需要等待一整个锁有效期的时间才能重新提供锁服务。

### 使锁算法更加可靠:锁续约

如果客户端执行的工作由小步骤组成，则默认情况下可以使用较小的锁有效时间，并扩展实现锁延迟机制的算法

当一个Client在工作计算到一半时发现锁的剩余有效期不足。可以向Redis实例发送续约锁的Lua脚本。如果key存在且value仍是该客户端设置的值，则延长key的TTL。

为了提高系统的可用性，每个Client申请锁续约的次数需要有一个最大限制，避免其不断续约造成该key长时间不可用。

## 参考

> - [Distributed locks with Redis](https://redis.io/topics/distlock)
> - [RedLock算法-使用redis实现分布式锁服务](https://www.jianshu.com/p/fba7dd6dcef5)
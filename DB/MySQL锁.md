# MySQL 的锁

锁是数据库管理系统区别文件系统的重要特征之一。锁机制使得在对数据库进行并发访问时，可以保障数据的完整性和一致性。

## 锁等级

- **表级锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
- **页面锁**：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
- **行级锁**：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

## InnoDB 锁类型

### 行级锁

**InnoDB 行锁是通过给`索引项`加锁来实现的，即只有通过索引条件检索数据，InnoDB 才使用行级锁，否则将使用表锁！**

InnoDB 实现了两种类型的行级锁：

- 共享锁（也称为 S 锁）：允许事务读取一行数据。可以使用 SQL 语句 `select * from tableName where … lock in share mode;` 手动加 S 锁。
- 独占锁（也称为 X 锁,排他锁）：允许事务删除或更新一行数据。可以使用 SQL 语句 `select * from tableName where … for update;` 手动加 X 锁。

S 锁和 S 锁是**兼容**的，X 锁和其它锁都**不兼容**，举个例子，事务 T1 获取了一个行 r1 的 S 锁，另外事务 T2 可以立即获得行 r1 的 S 锁，此时 T1 和 T2 共同获得行 r1 的 S 锁，此种情况称为**锁兼容**，但是另外一个事务 T2 此时如果想获得行 r1 的 X 锁，则必须等待 T1 对行 r 锁的释放，此种情况也成为**锁冲突**。

### 表级锁

为了实现多粒度的锁机制，InnoDB 还有两种内部使用的**意向锁**，由 InnoDB 自动添加，且都是**表级别的锁**。

- **意向共享锁（IS）**：事务即将给表中的各个行设置共享锁，事务给数据行加 S 锁前必须获得该表的 IS 锁。
- **意向排他锁（IX）**：事务即将给表中的各个行设置排他锁，事务给数据行加 X 锁前必须获得该表 IX 锁。

意向锁的**主要目的**是为了使得**行锁**和**表锁**共存。下表列出了行级锁和表级意向锁的兼容性：

| 锁类型 | X    | IX   | S    | IS   |
| ------ | ---- | ---- | ---- | ---- |
| X      | 冲突 | 冲突 | 冲突 | 冲突 |
| IX     | 冲突 | 兼容 | 冲突 | 兼容 |
| S      | 冲突 | 冲突 | 兼容 | 兼容 |
| IS     | 冲突 | 兼容 | 兼容 | 兼容 |

## 行锁的算法

InnoDB 存储引擎使用三种行锁的算法用来满足相关事务隔离级别的要求。

- **Record Locks**：该锁为索引记录上的锁，如果表中没有定义索引，InnoDB 会默认为该表创建一个隐藏的聚簇索引，并使用该索引锁定记录。
- **Gap Locks**：该锁会锁定一个范围，但是不括记录本身。可以通过修改隔离级别为 READ COMMITTED 或者配置 innodb_locks_unsafe_for_binlog 参数为 ON。
- **Next-key Locks**：该锁就是 Record Locks 和 Gap Locks 的组合，即锁定一个范围并且锁定该记录本身。InnoDB 使用 Next-key Locks 解决幻读问题。需要注意的是，如果索引有唯一属性，则 InnnoDB 会自动将 Next-key Locks 降级为 Record Locks。举个例子，如果一个索引有 1, 3, 5 三个值，则该索引锁定的区间为 (-∞,1], (1,3], (3,5], (5,+ ∞)。

## 死锁

InnoDB 引擎采取的是 wait-for graph(等待图)的方法来自动检测死锁，如果发现死锁会自动回滚一个事务。

## 锁的优化建议

- **合理设计索引**，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。
- **尽可能减少基于范围的数据检索过滤条件**，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。
- **尽量控制事务的大小**，减少锁定的资源量和锁定时间长度。
- **在业务环境允许的情况下，尽量使用较低级别的事务隔离**，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。

## 数据库的乐观锁和悲观锁是什么?

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

- **悲观锁**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作;共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。一般**多写的场景**下用悲观锁就比较合适。

- **乐观锁**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁**适用于多读的应用类型**，这样可以提高吞吐量，CAS(compare and swap)算法和 MVCC 版本控制。CAS 一般情况下是一个自旋操作，即不断的重试；
  - CAS 缺点：
    - ABA 问题
    - 循环时间长开销大：自旋 CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给 CPU 带来非常大的执行开销。
    - 只能保证一个共享变量的原子操作

### CAS 算法

非阻塞同步，CAS 算法三个操作数

- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B

仅当 A==V，CAS 才通过原子的方式用新值 B 来更新 V 的值。否则不会执行任何操作。一般情况下是自旋操作

**ABA 问题：**

变量 V 初次读取是值为 A，但在这段时间它的值可能被改为其他值，然后又改回 A，但 CAS 操作会误认为它没被修改过。这就是 ABA 问题

**循环时间长开销大：**

长时间自旋，会带来 CPU 的大量执行开销。

**只能保证一个共享变量的原子操作：**

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。

## 参考

> - [MySQL 事务隔离级别和锁](https://www.ibm.com/developerworks/cn/opensource/os-mysql-transaction-isolation-levels-and-locks/index.html)
> - [MySQL 中的锁](https://www.ibm.com/developerworks/cn/opensource/os-mysql-transaction-isolation-levels-and-locks/index.html)
> - [全面了解 mysql 锁机制（InnoDB）与问题排查](https://juejin.im/post/5b82e0196fb9a019f47d1823)
> - [面试必备之乐观锁与悲观锁](https://juejin.im/post/5b4977ae5188251b146b2fc8)
